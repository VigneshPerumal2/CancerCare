# CancerCare

## **Teammates**
  **Amulya Murahari (murahari.a)
  Vignesh Perumal Samy (perumalsamy.v)
  Sunayana Shivanagi   (shivanagi.s)**

**Cancer Therapy and Clonal Hematopoiesis**

**Data Source Link : https://www.cbioportal.org/study/clinicalData?id=msk_ch_2020**


Cancer is a disease of the genome, caused by genetic variations in genes. These mutations impact the processes that regulate how cells interact with their environment and grow.

The goal of this project is to develop a database tool that will allow us to examine patient information and get insightful knowledge about how frequently cancer occurs. Twitter database schema is also included in the cancer care system. The data is based on assessing the changing gene conditions in patients over time and will then be used to determine which type of treatment is most likely to save the patient because genes play a vital part in cancer detection.


## **ERD DIAGRAM**

![MicrosoftTeams-image (8)](https://user-images.githubusercontent.com/37552813/205798554-bf870fc7-d029-430d-a1f1-b1f7958f383e.png)






**Database Connection (Scraping/Gathering)**

    

import pandas as pd
data = pd.read_csv (r'clinical_data.csv',index_col=False)   
df = pd.DataFrame(data)


**Data Validation**

**Completeness:** Refers to the degree to which an entity includes data required to describe a real-world object. In tables in relational database systems, completeness can be measured by the presence of null values, which is usually interpreted as a missing value.

**Consistency:** The degree to which a set of semantic rules are violated such as a specific data type, an interval for a numerical column, or a set of values for a categorical column.

**Accuracy:** The correctness of the data and can be measured in two dimensions: syntactic and semantic. Syntactic accuracy compares the representation of a value with a corresponding definition domain, whereas semantic accuracy compares a value with its real-world representation.


**Visualizing Missing Data and Validate data to check missing values (Before Cleaning)**

Visualizing the missing values

**Barplot**
The barplot provides a simple plot where each bar represents a column within the dataframe. The height of the bar indicates how complete that column is, i.e, how many non-null values are present. It can be generated by calling upon:
msno.bar(df)

**Matrix Plot**
The matrix plot is a great tool if you are working with depth-related data or time-series data. It provides a colour fill for each column. When data is present, the plot is shaded in grey (or your colour of choice), and when it is absent the plot is displayed in white.
msno.matrix(df)

**Heatmap**
The heatmap is used to identify correlations of the nullity between each of the different columns. In other words, it can be used to identify if there is a relationship in the presence of null values between each of the columns.

Values close to positive 1 indicate that the presence of null values in one column is correlated with the presence of null values in another column.

Values close to negative 1 indicate that the presence of null values in one column is anti-correlated with the presence of null values in another column. In other words, when null values are present in one column, there are data values present in the other column, and vice versa.
msno.heatmap(df)

**Dendrogram**
The dendrogram plot provides a tree-like graph generated through hierarchical clustering and groups together columns that have strong correlations in nullity.

If a number of columns are grouped together at level zero, then the presence of nulls in one of those columns is directly related to the presence or absence of nulls in the others columns. The more separated the columns in the tree, the less likely the null values can be correlated between the columns.
msno.dendrogram(df)






<img width="921" alt="MicrosoftTeams-image (11)" src="https://user-images.githubusercontent.com/37552813/205804097-c35fa8ee-6049-4918-a3ec-607fd7d0562b.png">


<img width="1187" alt="MicrosoftTeams-image (12)" src="https://user-images.githubusercontent.com/37552813/205804183-94ff1a72-003d-4c04-9246-4ec436f4b8e5.png">


<img width="1156" alt="MicrosoftTeams-image (13)" src="https://user-images.githubusercontent.com/37552813/205804323-27f3686f-ecad-42e7-b230-456c341b4287.png">


<img width="1129" alt="MicrosoftTeams-image (15)" src="https://user-images.githubusercontent.com/37552813/205804998-9c0943b1-4a37-43d2-8128-1541d42162e8.png">


**Validate data to fill missing values (Munging)**


Filling Missing values
This method fills each missing row with the value of the nearest one above it.
It fills each missing row in the DataFrame with the nearest value below it.
Validating missing data

**Data Completeness completed ...
Visualizing Missing Data and Validate data to check missing values (After Cleaning)**


Visualizing the missing values

**Barplot**
The barplot provides a simple plot where each bar represents a column within the dataframe. The height of the bar indicates how complete that column is, i.e, how many non-null values are present. It can be generated by calling upon:
msno.bar(df)


**Matrix Plot**
The matrix plot is a great tool if you are working with depth-related data or time-series data. It provides a colour fill for each column. When data is present, the plot is shaded in grey (or your colour of choice), and when it is absent the plot is displayed in white.


**Heatmap**
The heatmap is used to identify correlations of the nullity between each of the different columns. In other words, it can be used to identify if there is a relationship in the presence of null values between each of the columns.

Values close to positive 1 indicate that the presence of null values in one column is correlated with the presence of null values in another column.

Values close to negative 1 indicate that the presence of null values in one column is anti-correlated with the presence of null values in another column. In other words, when null values are present in one column, there are data values present in the other column, and vice versa.
msno.heatmap(df)


**Dendrogram**
The dendrogram plot provides a tree-like graph generated through hierarchical clustering and groups together columns that have strong correlations in nullity.

If a number of columns are grouped together at level zero, then the presence of nulls in one of those columns is directly related to the presence or absence of nulls in the others columns. The more separated the columns in the tree, the less likely the null values can be correlated between the columns.


<img width="658" alt="MicrosoftTeams-image (9)" src="https://user-images.githubusercontent.com/37552813/205802688-83f73999-8e3f-488b-8b4b-e25a169c002d.png">


<img width="912" alt="MicrosoftTeams-image (16)" src="https://user-images.githubusercontent.com/37552813/205805755-b3092827-36c0-43e7-bcca-dc5e2928ca37.png">


<img width="900" alt="MicrosoftTeams-image (17)" src="https://user-images.githubusercontent.com/37552813/205805857-d5f1bc8b-a2a7-4a8a-b40e-d4dea9eae220.png">


<img width="867" alt="MicrosoftTeams-image (18)" src="https://user-images.githubusercontent.com/37552813/205805923-a15d55d1-a062-4462-9763-bae4d0733064.png">


<img width="930" alt="MicrosoftTeams-image (19)" src="https://user-images.githubusercontent.com/37552813/205805968-69625d98-0cfd-490f-b6b2-acac3c0e1ef6.png">


**CREATING TABLES**


```
PATIENT TABLE
conn = sqlite3.connect('cancer.db')
print("Opened database successfully");
conn.execute('''DROP TABLE IF EXISTS PATIENT;''')
conn.execute('''CREATE TABLE IF NOT EXISTS PATIENT
         (
         Patient_ID TEXT PRIMARY KEY,
         Sample_ID TEXT  ,
         Age INTEGER ,
         Race TEXT  ,
         Sex TEXT   ,
         Number_of_Samples_Per_Patient INTEGER,
         Smoking_Status TEXT
         );''')

print("Patient Table created successfully");

conn.close()
```
| Patient\_ID | Sample\_ID | Age | Race | Sex | Number\_of\_Samples\_Per\_Patient | Smoking\_Status |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| P-0000004 | P-0000004-N01 | 39.7399025 | White | Female | 1 | Never smoker |
| P-0000015 | P-0000015-N01 | 44.44079208 | White | Female | 1 | Never smoker |
| P-0000023 | P-0000023-N01 | 61.31964493 | White | Male | 1 | Never smoker |
| P-0000024 | P-0000024-N01 | 61.34428406 | White | Female | 1 | Former Smoker |
| P-0000025 | P-0000025-N01 | 72.67350769 | White | Female | 1 | Former Smoker |
| P-0000026 | P-0000026-N01 | 71.70978546 | Asian | Female | 1 | Former Smoker |
| P-0000027 | P-0000027-N01 | 81.00479126 | White | Female | 1 | Never smoker |
| P-0000034 | P-0000034-N01 | 76.88432312 | White | Male | 1 | Former Smoker |
| P-0000037 | P-0000037-N01 | 64.35317993 | Asian | Male | 1 | Never smoker |
| P-0000039 | P-0000039-N01 | 69.01300812 | White | Male | 1 | Former Smoker |

```
#CANCER_TYPE TABLE
conn = sqlite3.connect('cancer.db')
print("Opened database successfully");
conn.execute('''DROP TABLE IF EXISTS CANCER_TYPE;''')
conn.execute('''CREATE TABLE IF NOT EXISTS CANCER_TYPE
        (
         Cancer_Type_ID INTEGER PRIMARY KEY AUTOINCREMENT,
         Cancer_Type TEXT ,
         Patient_ID  TEXT  ,
         Cancer_Type_Detailed  TEXT  ,
         All_therapy_at_MSKCC TEXT ,
         FOREIGN KEY(Patient_ID) REFERENCES PATIENT(Patient_ID));''')

print("Cancer_Type Table created successfully");

conn.close()
```
| Cancer\_Type\_ID | Cancer\_Type | Patient\_ID | Cancer\_Type\_Detailed | All\_therapy\_at\_MSKCC |
| :--- | :--- | :--- | :--- | :--- |
| 1 | Breast Cancer | P-0000004 | Invasive Breast Carcinoma | No |
| 2 | Breast Cancer | P-0000015 | Invasive Breast Carcinoma | No |
| 3 | Mesothelioma | P-0000023 | Peritoneal Mesothelioma | No |
| 4 | Endometrial Cancer | P-0000024 | Other Uterine Tumor | No |
| 5 | Endometrial Cancer | P-0000025 | Other Uterine Tumor | Yes |
| 6 | Endometrial Cancer | P-0000026 | Other Uterine Tumor | No |
| 7 | Mesothelioma | P-0000027 | Peritoneal Mesothelioma | Yes |
| 8 | Bladder Cancer | P-0000034 | Bladder Adenocarcinoma | No |
| 9 | Hepatobiliary Cancer | P-0000037 | Hepatocellular Carcinoma | No |
| 10 | Mesothelioma | P-0000039 | Peritoneal Mesothelioma | Yes |

```
#DIAGNOSIS TABLE
conn = sqlite3.connect('cancer.db')
print("Opened database successfully");
conn.execute('''DROP TABLE IF EXISTS DIAGNOSIS;''')
conn.execute('''CREATE TABLE IF NOT EXISTS DIAGNOSIS

         (Diagnosis_ID INTEGER PRIMARY KEY AUTOINCREMENT,
          Patient_ID TEXT,
          Time_From_Diagnosis INTEGER,
          Time_to_Blood_Draw_from_Treatment INTEGER,
          FOREIGN KEY(Patient_ID) REFERENCES PATIENT(Patient_ID));''')

print("Diagnosis Table created successfully");

conn.close()
```
| Diagnosis\_ID | Patient\_ID | Time\_From\_Diagnosis | Time\_to\_Blood\_Draw\_from\_Treatment |
| :--- | :--- | :--- | :--- |
| 1 | P-0000004 | 991 | 609 |
| 2 | P-0000015 | 2558 | 5 |
| 3 | P-0000023 | 245 | 166 |
| 4 | P-0000024 | 6313 | 91 |
| 5 | P-0000025 | 1161 | 1097 |
| 6 | P-0000026 | 1624 | 1197 |
| 7 | P-0000027 | 549 | 267 |
| 8 | P-0000034 | 488 | 692 |
| 9 | P-0000037 | 2365 | 692 |
| 10 | P-0000039 | 904 | 785 |

```
#ANTIBIOTICS TABLE
conn = sqlite3.connect('cancer.db')
print("Opened database successfully");
conn.execute('''DROP TABLE IF EXISTS ANTIBIOTICS;''')
conn.execute('''CREATE TABLE IF NOT EXISTS ANTIBIOTICS

         (Alkylating_Agent_Treatment_ID INTEGER PRIMARY KEY AUTOINCREMENT ,
          Alkylating_Agent_Treatment TEXT,
          Patient_ID TEXT,
          Cumulative_Exposure_to_Alkylatin_Agent TEXT,
          Anthracycline_Treatment TEXT,
          Cumulative_Exposure_to_Anthracycline TEXT,
          Targeted_Therapy_Treatment TEXT,
          Cumulative_Exposure_to_Targeted_Therapy TEXT,
          Taxane_Treatment TEXT,
          Cumulative_Exposure_to_Taxane TEXT,
          FOREIGN KEY(Patient_ID) REFERENCES PATIENT(Patient_ID) );''')

print("Antibiotics Table created successfully");

conn.close()
```
| Alkylating\_Agent\_Treatment\_ID | Alkylating\_Agent\_Treatment | Patient\_ID | Cumulative\_Exposure\_to\_Alkylatin\_Agent | Anthracycline\_Treatment | Cumulative\_Exposure\_to\_Anthracycline | Targeted\_Therapy\_Treatment | Cumulative\_Exposure\_to\_Targeted\_Therapy | Taxane\_Treatment | Cumulative\_Exposure\_to\_Taxane |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | Yes | P-0000004 | 1st tertile | No | No treatment | Yes | 3rd tertile | Yes | 2nd tertile |
| 2 | Yes | P-0000015 | 1st tertile | No | No treatment | Yes | 3rd tertile | Yes | 2nd tertile |
| 3 | Yes | P-0000023 | 1st tertile | No | No treatment | Yes | 3rd tertile | Yes | 2nd tertile |
| 4 | Yes | P-0000024 | 1st tertile | No | No treatment | Yes | 3rd tertile | Yes | 2nd tertile |
| 5 | No | P-0000025 | No treatment | No | No treatment | Yes | 2nd tertile | Yes | 3rd tertile |
| 6 | No | P-0000026 | No treatment | No | No treatment | Yes | 2nd tertile | Yes | 3rd tertile |
| 7 | No | P-0000027 | No treatment | No | No treatment | No | No treatment | No | No treatment |
| 8 | No | P-0000034 | No treatment | No | No treatment | No | No treatment | No | No treatment |
| 9 | No | P-0000037 | No treatment | No | No treatment | No | No treatment | No | No treatment |
| 10 | No | P-0000039 | No treatment | No | No treatment | No | No treatment | No | No treatment |

```
#RADIOTHERAPY TABLE
conn = sqlite3.connect('cancer.db')
print("Opened database successfully");
conn.execute('''DROP TABLE IF EXISTS RADIOTHERAPY;''')
conn.execute('''CREATE TABLE IF NOT EXISTS RADIOTHERAPY
         (
          Radiation_Therapy_ID INTEGER PRIMARY KEY AUTOINCREMENT,
          Patient_ID TEXT,
          Immunotherapy_Treatment TEXT,
          Radiation_Therapy TEXT,
          Radiotherapy_Treatment TEXT,
          Cumulative_Exposure_to_Immunotherapy TEXT,
          FOREIGN KEY(Patient_ID) REFERENCES PATIENT(Patient_ID));''')

print("Radiotherapy Table created successfully");

conn.close()
```
| Radiation\_Therapy\_ID | Patient\_ID | Immunotherapy\_Treatment | Radiation\_Therapy | Radiotherapy\_Treatment | Cumulative\_Exposure\_to\_Immunotherapy |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | P-0000004 | No | Yes | No | No treatment |
| 2 | P-0000015 | No | No | No | No treatment |
| 3 | P-0000023 | No | No | No | No treatment |
| 4 | P-0000024 | No | No | No | No treatment |
| 5 | P-0000025 | No | No | No | No treatment |
| 6 | P-0000026 | No | No | No | No treatment |
| 7 | P-0000027 | No | No | No | No treatment |
| 8 | P-0000034 | Yes | No | No | 2nd tertile |
| 9 | P-0000037 | Yes | No | No | 2nd tertile |
| 10 | P-0000039 | Yes | Yes | No | 3rd tertile |

```
#CHEMOTHERAPY TABLE
conn = sqlite3.connect('cancer.db')
print("Opened database successfully");
conn.execute('''DROP TABLE IF EXISTS CHEMOTHERAPY;''')
conn.execute('''CREATE TABLE IF NOT EXISTS CHEMOTHERAPY

         (
          Chemotherapy_Treatment_ID INTEGER PRIMARY KEY AUTOINCREMENT,
          Chemotherapy_Treatment TEXT,
          Patient_ID TEXT,
          Cytotoxic_Chemotherapy_Treatment TEXT ,
          Cumulative_Exposure_to_Other_Cytotoxic_Therapy TEXT ,
          Oxaliplatin_Treatment TEXT ,
          Other_Cytotoxic_Treatment TEXT ,
          Cumulative_Exposure_to_Oxaliplatin TEXT ,
          Cytotoxic_Chemotherapy_Treatment_Tertile TEXT ,
          FOREIGN KEY(Patient_ID) REFERENCES PATIENT(Patient_ID));''')

print("Chemotherapy Table created successfully");

conn.close()
```
| Chemotherapy\_Treatment\_ID | Chemotherapy\_Treatment | Patient\_ID | Cytotoxic\_Chemotherapy\_Treatment | Cumulative\_Exposure\_to\_Other\_Cytotoxic\_Therapy | Oxaliplatin\_Treatment | Other\_Cytotoxic\_Treatment | Cumulative\_Exposure\_to\_Oxaliplatin | Cytotoxic\_Chemotherapy\_Treatment\_Tertile |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | Yes | P-0000004 | Yes | No treatment | No | No | No treatment | 1st tertile |
| 2 | Yes | P-0000015 | Yes | No treatment | No | No | No treatment | 1st tertile |
| 3 | Yes | P-0000023 | Yes | No treatment | No | No | No treatment | 2nd tertile |
| 4 | Yes | P-0000024 | Yes | No treatment | No | No | No treatment | 1st tertile |
| 5 | Yes | P-0000025 | Yes | No treatment | No | No | No treatment | 3rd tertile |
| 6 | Yes | P-0000026 | Yes | No treatment | No | No | No treatment | 2nd tertile |
| 7 | Yes | P-0000027 | Yes | No treatment | No | No | No treatment | 1st tertile |
| 8 | Yes | P-0000034 | Yes | No treatment | No | No | No treatment | 2nd tertile |
| 9 | Yes | P-0000037 | Yes | No treatment | No | No | No treatment | 2nd tertile |
| 10 | Yes | P-0000039 | Yes | No treatment | No | No | No treatment | 3rd tertile |

```
#ANTIMETABOLITE TABLE
conn = sqlite3.connect('cancer.db')
print("Opened database successfully");
conn.execute('''DROP TABLE IF EXISTS ANTIMETABOLITE;''')
conn.execute('''CREATE TABLE IF NOT EXISTS ANTIMETABOLITE

         (
          Antimetabolite_Treatment_ID INTEGER PRIMARY KEY AUTOINCREMENT,
          Antimetobolite_Treatment TEXT,
          Patient_ID TEXT,
          Cumulative_Exposure_to_Antimetabolite TEXT,
          Carboplatin_Treatment  TEXT,
          Cumulative_Exposure_to_Carboplatin TEXT,
          Cisplatin_Treatment TEXT,
          Cumulative_Exposure_to_Cisplatin TEXT,
          Platinum_Treatment TEXT,
          Cumulative_Exposure_to_Platinum TEXT,
          FOREIGN KEY(Patient_ID) REFERENCES PATIENT(Patient_ID));''')

print("Antimetabolite Table created successfully");

conn.close()
```
| Antimetabolite\_Treatment\_ID | Antimetobolite\_Treatment | Patient\_ID | Cumulative\_Exposure\_to\_Antimetabolite | Carboplatin\_Treatment | Cumulative\_Exposure\_to\_Carboplatin | Cisplatin\_Treatment | Cumulative\_Exposure\_to\_Cisplatin | Platinum\_Treatment | Cumulative\_Exposure\_to\_Platinum |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | Yes | P-0000004 | 3rd tertile | Yes | 2nd tertile | Yes | 3rd tertile | Yes | 3rd tertile |
| 2 | Yes | P-0000015 | 3rd tertile | Yes | 2nd tertile | Yes | 3rd tertile | Yes | 3rd tertile |
| 3 | Yes | P-0000023 | 2nd tertile | Yes | 2nd tertile | Yes | 3rd tertile | Yes | 3rd tertile |
| 4 | Yes | P-0000024 | 2nd tertile | Yes | 2nd tertile | Yes | 3rd tertile | Yes | 2nd tertile |
| 5 | No | P-0000025 | No treatment | Yes | 3rd tertile | No | No treatment | Yes | 3rd tertile |
| 6 | No | P-0000026 | No treatment | Yes | 3rd tertile | No | No treatment | Yes | 3rd tertile |
| 7 | Yes | P-0000027 | 2nd tertile | Yes | 1st tertile | No | No treatment | Yes | 1st tertile |
| 8 | Yes | P-0000034 | 3rd tertile | Yes | 1st tertile | Yes | 2nd tertile | Yes | 2nd tertile |
| 9 | Yes | P-0000037 | 3rd tertile | Yes | 1st tertile | Yes | 2nd tertile | Yes | 2nd tertile |
| 10 | Yes | P-0000039 | 3rd tertile | Yes | 2nd tertile | Yes | 2nd tertile | Yes | 3rd tertile |

```
#MICROTUBULE TABLE
conn = sqlite3.connect('cancer.db')
print("Opened database successfully");
conn.execute('''DROP TABLE IF EXISTS MICROTUBULE;''')
conn.execute('''CREATE TABLE IF NOT EXISTS MICROTUBULE

         (
          Microtubule_ID  INTEGER PRIMARY KEY AUTOINCREMENT,
          EQD_Tertiles TEXT,
          Patient_ID TEXT,
          Oncotree_Code TEXT,
          Nucleoside_Analogue_Treatment  TEXT,
          Cumulative_Exposure_to_Microtubule_Damaging_Agent TEXT,
          Mutation_Count INTEGER,
          Folic_Acid_Analog_Treatment TEXT,
          FOREIGN KEY(Patient_ID) REFERENCES PATIENT(Patient_ID));''')

print("Microtubule Table created successfully");

conn.close()
```
| Microtubule\_ID | EQD\_Tertiles | Patient\_ID | Oncotree\_Code | Nucleoside\_Analogue\_Treatment | Cumulative\_Exposure\_to\_Microtubule\_Damaging\_Agent | Mutation\_Count | Folic\_Acid\_Analog\_Treatment |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | 1st tertile | P-0000004 | BRCA | Yes | No treatment | 2 | Yes |
| 2 | No radiation | P-0000015 | BRCA | Yes | No treatment | 2 | Yes |
| 3 | No radiation | P-0000023 | PEMESO | Yes | No treatment | 2 | Yes |
| 4 | No radiation | P-0000024 | OUTT | Yes | No treatment | 2 | Yes |
| 5 | No radiation | P-0000025 | OUTT | No | No treatment | 2 | No |
| 6 | No radiation | P-0000026 | OUTT | No | No treatment | 2 | No |
| 7 | No radiation | P-0000027 | PEMESO | No | No treatment | 2 | Yes |
| 8 | No radiation | P-0000034 | BLAD | Yes | No treatment | 1 | Yes |
| 9 | No radiation | P-0000037 | HCC | Yes | No treatment | 1 | Yes |
| 10 | 1st tertile | P-0000039 | PEMESO | No | No treatment | 1 | Yes |

```
#TOPOISOMERASE TABLE
conn = sqlite3.connect('cancer.db')
print("Opened database successfully");
conn.execute('''DROP TABLE IF EXISTS TOPOISOMERASE;''')
conn.execute('''CREATE TABLE IF NOT EXISTS TOPOISOMERASE

         (Topoisomerase_Treatment_ID INTEGER PRIMARY KEY AUTOINCREMENT,
          Cumulative_Exposure_to_Topoisomerase_I_Inhibitor TEXT,
          Patient_ID TEXT,
          Cumulative_Exposure_to_Topoisomerase_II_Inhibitor TEXT,
          Topoisomerase_I_Inhibitor_Treatment TEXT,
          Topoisomerase_II_Inhibitor_Treatment TEXT,
          FOREIGN KEY(Patient_ID) REFERENCES PATIENT(Patient_ID));''')

print("Topoisomerase Table created successfully");

conn.close()
```
| Topoisomerase\_Treatment\_ID | Cumulative\_Exposure\_to\_Topoisomerase\_I\_Inhibitor | Patient\_ID | Cumulative\_Exposure\_to\_Topoisomerase\_II\_Inhibitor | Topoisomerase\_I\_Inhibitor\_Treatment | Topoisomerase\_II\_Inhibitor\_Treatment |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | No treatment | P-0000004 | No treatment | No | No |
| 2 | No treatment | P-0000015 | No treatment | No | No |
| 3 | No treatment | P-0000023 | No treatment | No | No |
| 4 | No treatment | P-0000024 | No treatment | No | No |
| 5 | No treatment | P-0000025 | No treatment | No | No |
| 6 | No treatment | P-0000026 | No treatment | No | No |
| 7 | No treatment | P-0000027 | No treatment | No | No |
| 8 | No treatment | P-0000034 | No treatment | No | No |
| 9 | No treatment | P-0000037 | No treatment | No | No |
| 10 | No treatment | P-0000039 | No treatment | No | No |

     
**INSERTING TABLES**


```
#INSERT PATIENT TABLE VALUES
conn = sqlite3.connect('cancer.db')
for row in df.itertuples():
    conn.execute('INSERT INTO PATIENT(Patient_ID, Sample_ID, Age, Race, Sex, Number_of_Samples_Per_Patient, Smoking_Status) VALUES (?,?,?,?,?,?,?)',(
                row.Patient_ID, 
                row.Sample_ID,
                row.Age,
                row.Race,
                row.Sex,
                row.Number_of_Samples_Per_Patient,
                row.Smoking_Status
                )
                )
    conn.commit()
conn.close()
```


```
#INSERT CANCER_TYPE TABLE VALUES
conn = sqlite3.connect('cancer.db')
for row in df.itertuples():
    conn.execute('INSERT INTO CANCER_TYPE( Cancer_Type, Patient_ID, Cancer_Type_Detailed, All_therapy_at_MSKCC) VALUES (?,?,?,?)',(
                row.Cancer_Type,
                row.Patient_ID,
                row.Cancer_Type_Detailed,
                row.All_therapy_at_MSKCC
                )
                )
    conn.commit()
conn.close()
```


```
#INSERT DIAGNOSIS TABLE VALUES
conn = sqlite3.connect('cancer.db')
for row in df.itertuples():
    conn.execute('INSERT INTO DIAGNOSIS( Patient_ID, Time_from_Diagnosis, Time_to_Blood_Draw_from_Treatment ) VALUES (?,?,?)',(
                row.Patient_ID,
                row.Time_from_Diagnosis,
                row.Time_to_Blood_Draw_from_Treatment
                )
                )
    conn.commit()
conn.close()
```


```
#INSERT ANTIBIOTICS TABLE VALUES
conn = sqlite3.connect('cancer.db')
for row in df.itertuples():
    conn.execute('INSERT INTO ANTIBIOTICS( Alkylating_Agent_Treatment, Patient_ID, Cumulative_Exposure_to_Alkylatin_Agent, Anthracycline_Treatment, Cumulative_Exposure_to_Anthracycline, Targeted_Therapy_Treatment, Cumulative_Exposure_to_Targeted_Therapy, Taxane_Treatment, Cumulative_Exposure_to_Taxane) VALUES (?,?,?,?,?,?,?,?,?)',(
                row.Alkylating_Agent_Treatment,
                row.Patient_ID,
                row.Cumulative_Exposure_to_Alkylatin_Agent,
                row.Anthracycline_Treatment,
                row.Cumulative_Exposure_to_Anthracycline,
                row.Targeted_Therapy_Treatment,
                row.Cumulative_Exposure_to_Targeted_Therapy,
                row.Taxane_Treatment,
                row.Cumulative_Exposure_to_Taxane
                )
                )
    conn.commit()
conn.close()
```


```
#INSERT RADIOTHERAPY TABLE VALUES
conn = sqlite3.connect('cancer.db')
for row in df.itertuples():
    conn.execute('INSERT INTO RADIOTHERAPY( Patient_ID, Immunotherapy_Treatment, Radiation_Therapy, Radiotherapy_Treatment, Cumulative_Exposure_to_Immunotherapy) VALUES (?,?,?,?,?)',(
                row.Patient_ID,
                row.Immunotherapy_Treatment,
                row.Radiation_Therapy,
                row.Radiotherapy_Treatment,
                row.Cumulative_Exposure_to_Immunotherapy
                )
                )
    conn.commit()
conn.close()
```


```
#INSERT CHEMOTHERAPY TABLE VALUES
conn = sqlite3.connect('cancer.db')
for row in df.itertuples():
    conn.execute('INSERT INTO CHEMOTHERAPY( Chemotherapy_Treatment, Patient_ID, Cytotoxic_Chemotherapy_Treatment, Cumulative_Exposure_to_Other_Cytotoxic_Therapy, Oxaliplatin_Treatment,Other_Cytotoxic_Treatment, Cumulative_Exposure_to_Oxaliplatin, Cytotoxic_Chemotherapy_Treatment_Tertile) VALUES (?,?,?,?,?,?,?,?)',(
                row.Chemotherapy_Treatment,
                row.Patient_ID,
                row.Cytotoxic_Chemotherapy_Treatment,
                row.Cumulative_Exposure_to_Other_Cytotoxic_Therapy,
                row.Oxaliplatin_Treatment,
                row.Other_Cytotoxic_Treatment,
                row.Cumulative_Exposure_to_Oxaliplatin,
                row.Cytotoxic_Chemotherapy_Treatment_Tertile
                )
                )
    conn.commit()
conn.close()
```


```
#INSERT ANTIMETABOLITE TABLE VALUES
conn = sqlite3.connect('cancer.db')
for row in df.itertuples():
    conn.execute('INSERT INTO ANTIMETABOLITE( Antimetobolite_Treatment,Patient_ID, Cumulative_Exposure_to_Antimetabolite, Carboplatin_Treatment, Cumulative_Exposure_to_Carboplatin,Cisplatin_Treatment, Cumulative_Exposure_to_Cisplatin,Platinum_Treatment, Cumulative_Exposure_to_Platinum) VALUES (?,?,?,?,?,?,?,?,?)',(
                row.Antimetobolite_Treatment,
                row.Patient_ID,
                row.Cumulative_Exposure_to_Antimetabolite,
                row.Carboplatin_Treatment,
                row.Cumulative_Exposure_to_Carboplatin,
                row.Cisplatin_Treatment,
                row.Cumulative_Exposure_to_Cisplatin,
                row.Platinum_Treatment,
                row.Cumulative_Exposure_to_Platinum
                )
                )
    conn.commit()
conn.close()
```


```
#INSERT MICROTUBULE TABLE VALUES
conn = sqlite3.connect('cancer.db')
for row in df.itertuples():
    conn.execute('INSERT INTO MICROTUBULE( EQD_Tertiles, Patient_ID, Oncotree_Code, Nucleoside_Analogue_Treatment, Cumulative_Exposure_to_Microtubule_Damaging_Agent,Mutation_Count, Folic_Acid_Analog_Treatment ) VALUES (?,?,?,?,?,?,?)',
               (
                row.EQD_Tertiles,
                row.Patient_ID,
                row.Oncotree_Code,
                row.Nucleoside_Analogue_Treatment,
                row.Cumulative_Exposure_to_Microtubule_Damaging_Agent,
                row.Mutation_Count,
                row.Folic_Acid_Analog_Treatment
                )
                )
    conn.commit()
conn.close()
```


```
#INSERT TOPOISOMERASE TABLE VALUES
conn = sqlite3.connect('cancer.db')
for row in df.itertuples():
    conn.execute('INSERT INTO TOPOISOMERASE( Cumulative_Exposure_to_Topoisomerase_I_Inhibitor, Patient_ID, Cumulative_Exposure_to_Topoisomerase_II_Inhibitor, Topoisomerase_I_Inhibitor_Treatment, Topoisomerase_II_Inhibitor_Treatment ) VALUES (?,?,?,?,?)',
               (
                row.Cumulative_Exposure_to_Topoisomerase_I_Inhibitor,
                row.Patient_ID,
                row.Cumulative_Exposure_to_Topoisomerase_II_Inhibitor,
                row.Topoisomerase_I_Inhibitor_Treatment,
                row.Topoisomerase_II_Inhibitor_Treatment
                )
                )
    conn.commit()
conn.close()

print("Data inserted :)");
```



**USE CASE QUERIES**


# Query 1 - Number of Mutation in Cancer Patients
## Description:
The number of mutations in cancer patients can vary greatly depending on the type of cancer and the individual patient. Some cancers, such as lung cancer, can have relatively few mutations, while others, such as certain types of leukemia, can have many mutations. In general, cancer is caused by a combination of genetic mutations that occur over time, which can lead to the uncontrolled growth of cells that make up the cancer. These mutations can be inherited, or they can develop as a result of environmental factors such as exposure to certain chemicals or radiation. It is important to note that not all mutations will lead to cancer, and some people may carry mutations that do not cause any health problems.
```


import sqlite3
import pandas as pd


con = sqlite3.connect('cancer.db')
con.execute('''DROP VIEW IF EXISTS No_Of_Mutations;''')
q1 = (
con.execute('''CREATE VIEW No_Of_Mutations AS
SELECT  P.Patient_ID,P.Sample_ID,M.Mutation_Count
FROM PATIENT P
LEFT JOIN MICROTUBULE M
    ON P.Patient_ID = M.Patient_ID
UNION
SELECT  P.Patient_ID,P.Sample_ID,M.Mutation_Count
FROM MICROTUBULE M
LEFT JOIN PATIENT P
    ON P.Patient_ID = M.Patient_ID;'''))

q1 = (con.execute(''' SELECT * FROM No_Of_Mutations;'''))


# Convert the SQL query to Pandas data Frame
r1 = pd.read_sql(''' SELECT * FROM No_Of_Mutations;''', con)
r1.head(1)
print(r1)


# Plotting Graph
import matplotlib.pyplot as plt
fig = plt.figure(figsize = (10, 5))

# creating the bar plot
plt.bar(r1['Mutation_Count'], r1['Mutation_Count'], color ='maroon',
        width = 0.4)
plt.xlabel("Mutation_Count")
plt.ylabel("No of mutations")
plt.title("Number of Mutation in Cancer Patients")
plt.show()
```

<img width="900" alt="MicrosoftTeams-image (20)" src="https://user-images.githubusercontent.com/37552813/205807773-c991aae6-b59a-4efd-8bfa-75062ff68d54.png">


# Query 2 - Time to draw blood from the patient
## Description: 
The time it takes to draw blood from a patient can vary depending on a number of factors, including the skill of the person drawing the blood, the size and location of the veins, and the equipment being used. In general, the process of drawing blood is quick and relatively painless, and most people are able to have blood drawn in just a few minutes. The specific amount of time it takes to draw blood from a patient will depend on the individual situation.
```

import sqlite3
import pandas as pd


con = sqlite3.connect('cancer.db')
con.execute('''DROP VIEW IF EXISTS Time_to_draw_blood;''')
q1 = (
con.execute('''CREATE VIEW Time_to_draw_blood AS
SELECT  P.Patient_ID,P.Sample_ID,D.Time_to_Blood_Draw_from_Treatment
FROM PATIENT P
LEFT JOIN DIAGNOSIS D
    ON P.Patient_ID = D.Patient_ID
UNION
SELECT  P.Patient_ID,P.Sample_ID,D.Time_to_Blood_Draw_from_Treatment
FROM DIAGNOSIS D
LEFT JOIN PATIENT P
    ON P.Patient_ID = D.Patient_ID;'''))

q1 = (con.execute(''' SELECT * FROM Time_to_draw_blood;'''))


# Convert the SQL query to Pandas data Frame
r1 = pd.read_sql(''' SELECT * FROM Time_to_draw_blood;''', con)
r1.head(1)
print(r1)

# Plotting Graph
import matplotlib.pyplot as plt
fig = plt.figure(figsize = (10, 5))

# creating the bar plot
plt.bar(r1['Time_to_Blood_Draw_from_Treatment'], r1['Time_to_Blood_Draw_from_Treatment'], color ='maroon',
        width = 0.4)
plt.xlabel("Time_to_Blood_Draw_from_Treatment")
plt.ylabel("No of Time_to_Blood_Draw_from_Treatment")
plt.title("Time_to_Blood_Draw_from_Treatment in Cancer Patients")
plt.show()
```

<img width="892" alt="MicrosoftTeams-image (21)" src="https://user-images.githubusercontent.com/37552813/205807867-15053aad-4e2f-4f44-9483-0279dc79ae0f.png">

# Query 3 - Time_from_Diagnosis
## Description:
The time it takes to diagnose a patient can vary depending on the type of condition being diagnosed and the methods used to make a diagnosis. Some conditions, such as the common cold, can be diagnosed quickly based on the symptoms a patient is experiencing. Others, such as cancer, may require more extensive testing and analysis, which can take longer to complete. In general, the process of making a diagnosis can take anywhere from a few minutes to several weeks or more, depending on the individual situation. It is important for patients to work closely with their healthcare provider to ensure that they receive an accurate and timely diagnosis.

```
import sqlite3
import pandas as pd

con = sqlite3.connect('cancer.db')
con.execute('''DROP VIEW IF EXISTS Time_from_Diagnosis;''')
q1 = (
con.execute('''CREATE VIEW Time_from_Diagnosis AS
SELECT  P.Patient_ID,P.Sample_ID,D.Time_from_Diagnosis
FROM PATIENT P
LEFT JOIN DIAGNOSIS D
    ON P.Patient_ID = D.Patient_ID
UNION
SELECT  P.Patient_ID,P.Sample_ID,D.Time_from_Diagnosis
FROM DIAGNOSIS D
LEFT JOIN PATIENT P
    ON P.Patient_ID = D.Patient_ID;'''))


q1 = (con.execute(''' SELECT * FROM Time_from_Diagnosis;'''))


# Convert the SQL query to Pandas data Frame
r1 = pd.read_sql(''' SELECT * FROM Time_from_Diagnosis;''', con)
r1.head(1)
print(r1)

# Plotting Graph
import matplotlib.pyplot as plt
fig = plt.figure(figsize = (10, 5))

# creating the bar plot
plt.bar(r1['Time_From_Diagnosis'], r1['Time_From_Diagnosis'], color ='maroon',
        width = 0.4)
plt.xlabel("Time_from_Diagnosis")
plt.ylabel("No of Time")
plt.title("Time_from_Diagnosis in Cancer Patients")
plt.show()
```

<img width="610" alt="MicrosoftTeams-image (22)" src="https://user-images.githubusercontent.com/37552813/205807964-c31d55ac-4627-4849-a108-ff66b6529ea3.png">

# Query 4 - Smoking Status
## Description:
Smoking is a known risk factor for many types of cancer, including lung, throat, mouth, and bladder cancer. This is because the chemicals found in tobacco smoke can damage the DNA in cells, leading to mutations that can cause cancer to develop. In addition to causing cancer, smoking is also linked to a number of other serious health problems, such as heart disease, stroke, and lung diseases like emphysema and chronic bronchitis. Quitting smoking can reduce the risk of developing these conditions and can improve overall health.
```
import sqlite3
import pandas as pd

con = sqlite3.connect('cancer.db')
con.execute('''DROP VIEW IF EXISTS Smoking_Status;''')
q1 = (
con.execute('''CREATE VIEW Smoking_Status AS
SELECT  P1.Smoking_Status,COUNT(P1.Smoking_Status)
FROM PATIENT P1
LEFT JOIN PATIENT p2
    ON P1.Patient_ID = P2.Patient_ID
GROUP BY P1.Smoking_Status
ORDER BY P1.Smoking_Status;'''))


q1 = (con.execute(''' SELECT * FROM Time_from_Diagnosis;'''))


# Convert the SQL query to Pandas data Frame
r1 = pd.read_sql(''' SELECT * FROM Time_from_Diagnosis;''', con)
r1.head(1)
print(r1)

# Import libraries
from matplotlib import pyplot as plt
import numpy as np

# Creating dataset
labels = r1['Smoking_Status']
data = r1['COUNT(P1.Smoking_Status)']

# Creating plot
fig = plt.figure(figsize =(10, 7))
plt.pie(data, labels = labels)

# show plot
plt.show()
```

<img width="398" alt="MicrosoftTeams-image (23)" src="https://user-images.githubusercontent.com/37552813/205808370-a1b44cd0-f267-41d2-bb59-2c1781cd8410.png">


# Query 5 - Treatment Status
## Description: 
The treatment status of a cancer patient refers to the current stage of their treatment plan and the specific treatments they are receiving. Treatment for cancer can vary depending on the type and stage of the cancer, as well as the overall health and preferences of the patient. Some common types of cancer treatments include chemotherapy, radiation therapy, surgery, and targeted drug therapies. The treatment plan for a cancer patient may involve one or more of these treatments, and the treatment status can change over time as the patient responds to treatment and their condition changes. It is important for patients to work closely with their healthcare provider to develop an effective treatment plan that meets their needs.
```
import sqlite3
import pandas as pd

con = sqlite3.connect('cancer.db')
con.execute('''DROP VIEW IF EXISTS Treatment_Status;''')
q1 = (
con.execute('''CREATE VIEW Treatment_Status AS
SELECT  D.Carboplatin_Treatment,COUNT(D.Carboplatin_Treatment)
FROM ANTIMETABOLITE D
LEFT JOIN PATIENT P
    ON P.Patient_ID = D.Patient_ID
GROUP BY D.Carboplatin_Treatment
;'''))


q1 = (con.execute(''' SELECT * FROM Treatment_Status;'''))


# Convert the SQL query to Pandas data Frame
r1 = pd.read_sql(''' SELECT * FROM Treatment_Status;''', con)
r1.head(1)
print(r1)

# Import libraries
from matplotlib import pyplot as plt
import numpy as np

# Creating dataset
labels = r1['Carboplatin_Treatment']
data = r1['COUNT(D.Carboplatin_Treatment)']

# Creating plot
fig = plt.figure(figsize =(10, 7))
plt.pie(data, labels = labels)

# show plot
plt.show()
```

<img width="392" alt="MicrosoftTeams-image (24)" src="https://user-images.githubusercontent.com/37552813/205808467-fb1ab3e4-a841-4982-89c3-7d160b437abc.png">

# Query 6 - Cisplatin Treatment
## Description:
Cisplatin is a chemotherapy drug that is used to treat several types of cancer, including testicular cancer, ovarian cancer, and lung cancer. It works by damaging the DNA in cancer cells, which can prevent them from growing and dividing. Cisplatin is typically administered intravenously (through a vein) and is often given in combination with other chemotherapy drugs. Like other chemotherapy drugs, cisplatin can cause side effects, such as nausea, vomiting, and hair loss. It is important for patients to discuss the potential benefits and risks of cisplatin treatment with their healthcare provider.
```
import sqlite3
import pandas as pd

con = sqlite3.connect('cancer.db')
con.execute('''DROP VIEW IF EXISTS Cisplatin_Treatment;''')
q1 = (
con.execute('''CREATE VIEW Cisplatin_Treatment AS
SELECT  D.Cisplatin_Treatment,COUNT(D.Cisplatin_Treatment)
FROM ANTIMETABOLITE D
LEFT JOIN PATIENT P
    ON P.Patient_ID = D.Patient_ID
GROUP BY D.Cisplatin_Treatment
;'''))


q1 = (con.execute(''' SELECT * FROM Cisplatin_Treatment;'''))


# Convert the SQL query to Pandas data Frame
r1 = pd.read_sql(''' SELECT * FROM Cisplatin_Treatment;''', con)
r1.head(1)
print(r1)

# Import libraries
from matplotlib import pyplot as plt
import numpy as np

# Creating dataset
labels = r1['Cisplatin_Treatment']
data = r1['COUNT(D.Cisplatin_Treatment)']

# Creating plot
fig = plt.figure(figsize =(10, 7))
plt.pie(data, labels = labels)

# show plot
plt.show()
```

<img width="400" alt="MicrosoftTeams-image (25)" src="https://user-images.githubusercontent.com/37552813/205808576-4b5b695f-7207-4144-8615-d11cdf01350c.png">

# Query 7 - Antimetobolite_Treatment
## Description:
Antimetabolite treatment is a type of chemotherapy that is used to treat cancer. Antimetabolites are drugs that work by interfering with the way cells use certain molecules, such as DNA and RNA, to grow and divide. This can prevent cancer cells from growing and multiplying, which can slow down the progression of the cancer. There are several different types of antimetabolite drugs, including 5-fluorouracil, capecitabine, and gemcitabine. These drugs are often used in combination with other chemotherapy drugs and can cause side effects, such as nausea, vomiting, and low blood cell counts. It is important for patients to discuss the potential benefits and risks of antimetabolite treatment with their healthcare provider.
```
import sqlite3
import pandas as pd

con = sqlite3.connect('cancer.db')
con.execute('''DROP VIEW IF EXISTS Antimetobolite_Treatment;''')

q1 = (
con.execute('''CREATE VIEW Antimetobolite_Treatment AS
SELECT  D.Antimetobolite_Treatment,COUNT(D.Antimetobolite_Treatment)
FROM ANTIMETABOLITE D
LEFT JOIN PATIENT P
    ON P.Patient_ID = D.Patient_ID
GROUP BY D.Antimetobolite_Treatment
;
''' ))

q1 = (con.execute(''' SELECT * FROM Antimetobolite_Treatment;'''))

# Convert the SQL query to Pandas data Frame
r1 = pd.read_sql(''' SELECT * FROM Antimetobolite_Treatment;''', con)
r1.head(5)
print(r1)


# Import libraries
from matplotlib import pyplot as plt
import numpy as np

# Creating dataset
labels = r1['Antimetobolite_Treatment']
data = r1['COUNT(D.Antimetobolite_Treatment)']

# Creating plot
fig = plt.figure(figsize =(10, 7))
plt.pie(data, labels = labels)

# show plot
plt.show()
```

<img width="432" alt="MicrosoftTeams-image (26)" src="https://user-images.githubusercontent.com/37552813/205808860-d60cfd85-95e4-45c0-a980-6c2fb3986924.png">


# Query 8 - Anthracycline_Treatment
## Description:
Anthracycline treatment is a type of chemotherapy that is used to treat cancer. Anthracyclines are drugs that work by interfering with the way cancer cells produce energy, which can prevent them from growing and dividing. These drugs are often used in combination with other chemotherapy drugs and can be effective in treating a variety of different types of cancer, including breast cancer, leukemia, and lymphoma. Common side effects of anthracycline treatment include nausea, vomiting, hair loss, and an increased risk of infection. It is important for patients to discuss the potential benefits and risks of anthracycline treatment with their healthcare provider.
```
import sqlite3
import pandas as pd

con = sqlite3.connect('cancer.db')
con.execute('''DROP VIEW IF EXISTS Anthracycline_Treatment;''')
q1 = (
con.execute('''CREATE VIEW Anthracycline_Treatment AS
 SELECT D.Anthracycline_Treatment,COUNT(D.Anthracycline_Treatment)
 FROM ANTIBIOTICS D
 LEFT JOIN PATIENT P
 ON P.Patient_ID = D.Patient_ID
GROUP BY D.Anthracycline_Treatment
;
'''))


q1 = (con.execute(''' SELECT * FROM Anthracycline_Treatment;'''))


# Convert the SQL query to Pandas data Frame
r1 = pd.read_sql('''SELECT * FROM Anthracycline_Treatment;''', con)
r1.head(5)
print(r1)

# Import libraries
from matplotlib import pyplot as plt
import numpy as np

# Creating dataset
labels = r1['Anthracycline_Treatment']
data = r1['COUNT(D.Anthracycline_Treatment)']
# Creating plot
fig = plt.figure(figsize =(10, 7))
plt.pie(data, labels = labels)

# show plot
plt.show()
```

<img width="406" alt="MicrosoftTeams-image (28)" src="https://user-images.githubusercontent.com/37552813/205809413-5a6cd2c3-87ed-4f4d-8eeb-e01e8b441c4a.png">

# Query 9 - Alkylating_Agent_Treatment
## Description:
Alkylating agent treatment is a type of chemotherapy that is used to treat cancer. Alkylating agents are drugs that work by damaging the DNA in cancer cells, which can prevent them from growing and dividing. These drugs are often used in combination with other chemotherapy drugs and can be effective in treating a variety of different types of cancer, including leukemia, lymphoma, and cancers of the breast, lung, and ovaries. Common side effects of alkylating agent treatment include nausea, vomiting, hair loss, and an increased risk of infection. It is important for patients to discuss the potential benefits and risks of alkylating agent treatment with their healthcare provider.
```
import sqlite3
import pandas as pd

con = sqlite3.connect('cancer.db')
con.execute('''DROP VIEW IF EXISTS Alkylating_Agent_Treatment;''')
q1 = (
con.execute('''CREATE VIEW Alkylating_Agent_Treatment AS
SELECT  D.Alkylating_Agent_Treatment,COUNT(D.Alkylating_Agent_Treatment)
FROM ANTIBIOTICS D
LEFT JOIN PATIENT P
    ON P.Patient_ID = D.Patient_ID
GROUP BY D.Alkylating_Agent_Treatment
;
'''))

q1 = (con.execute(''' SELECT * FROM Alkylating_Agent_Treatment;'''))

# Convert the SQL query to Pandas data Frame
r1 = pd.read_sql(''' SELECT * FROM Alkylating_Agent_Treatment;''', con)
r1.head(5)
print(r1)


# Import libraries
from matplotlib import pyplot as plt
import numpy as np


# Creating dataset
labels = r1['Alkylating_Agent_Treatment']
data = r1['COUNT(D.Alkylating_Agent_Treatment)']


# Creating plot
fig = plt.figure(figsize =(10, 7))
plt.pie(data, labels = labels)


# show plot
plt.show()
```

<img width="437" alt="MicrosoftTeams-image (29)" src="https://user-images.githubusercontent.com/37552813/205809666-3628938a-ee4f-4c11-ab18-4eb581a45ddf.png">

# Query 10 - EQD_Tertiles
## Description:
EQD tertiles, also known as equivalent dose tertiles, is a way of measuring the amount of radiation that a person has received during cancer treatment. This measurement is used to compare the doses of different types of radiation and to determine the potential risks and benefits of different treatment options. EQD tertiles are calculated by dividing the total dose of radiation that a person receives into three equal groups, or tertiles. The first tertile represents the lowest doses of radiation, the second tertile represents moderate doses, and the third tertile represents the highest doses. This measurement can be helpful in determining the most appropriate treatment plan for a particular patient. It is important to note that the specific values of the EQD tertiles can vary depending on the type of cancer and the specific treatment being used.
```
import sqlite3
import pandas as pd

con = sqlite3.connect('cancer.db')
con.execute('''DROP VIEW IF EXISTS EQD_Tertiles;''')
q1 = (
con.execute('''CREATE VIEW EQD_Tertiles AS
SELECT  D.EQD_Tertiles,COUNT(D.EQD_Tertiles)
FROM MICROTUBULE D
LEFT JOIN PATIENT P
    ON P.Patient_ID = D.Patient_ID
GROUP BY D.EQD_Tertiles
;
''' ))

q1 = (con.execute(''' SELECT * FROM EQD_Tertiles;'''))

# Convert the SQL query to Pandas data Frame
r1 = pd.read_sql('''  SELECT * FROM EQD_Tertiles;''', con)
r1.head(5)
print(r1)

# Import libraries
from matplotlib import pyplot as plt
import numpy as np


# Creating dataset
labels = r1['EQD_Tertiles']
data = r1['COUNT(D.EQD_Tertiles)']


# Creating plot
fig = plt.figure(figsize =(10, 7))
plt.pie(data, labels = labels)


# show plot
plt.show()
```

<img width="406" alt="MicrosoftTeams-image (30)" src="https://user-images.githubusercontent.com/37552813/205809836-04e525e8-568b-43d6-a675-a1178146a2b0.png">


# Query 11 - Race
## Description:
Race is a social construct that is used to categorize people based on physical characteristics such as skin color, eye shape, and facial features. Race is not a biological concept and does not have a scientific basis. While there is no inherent link between race and cancer, certain racial and ethnic groups may have a higher risk of developing certain types of cancer due to a combination of genetic, environmental, and socioeconomic factors. For example, African Americans have a higher risk of developing prostate cancer and lung cancer than other racial and ethnic groups. It is important for healthcare providers to consider the potential impact of race on cancer risk and treatment when caring for patients.
```

import sqlite3
import pandas as pd

con = sqlite3.connect('cancer.db')
con.execute('''DROP VIEW IF EXISTS Race;''')
q1 = (
con.execute('''CREATE VIEW Race AS
SELECT  P1.Race,COUNT(P1.Race)
FROM PATIENT P1
LEFT JOIN PATIENT p2
    ON P1.Patient_ID = P2.Patient_ID
GROUP BY P1.Race
ORDER BY P1.Race
;'''))

q1 = (con.execute(''' SELECT * FROM Race;'''))


# Convert the SQL query to Pandas data Frame
r1 = pd.read_sql(''' SELECT * FROM Race;''', con)
r1.head(1)
print(r1)

# Import libraries
from matplotlib import pyplot as plt
import numpy as np

# Creating dataset
labels = r1['Race']
data = r1['COUNT(P1.Race)']

# Creating plot
fig = plt.figure(figsize =(10, 7))
plt.pie(data, labels = labels)

# show plot
plt.show()
```

<img width="374" alt="MicrosoftTeams-image (31)" src="https://user-images.githubusercontent.com/37552813/205809921-f7e4cdfb-b271-41a7-b05e-da83cb10947d.png">

# Query 12 - All_Therapy_At_MSKCC
## Description:
All therapy at MSKCC, also known as all therapy at Memorial Sloan Kettering Cancer Center, is a term that refers to the comprehensive range of cancer treatments offered at Memorial Sloan Kettering Cancer Center (MSKCC). MSKCC is a leading cancer center in the United States, known for its innovative and personalized approach to cancer care. The all therapy at MSKCC model encompasses a wide range of treatments, including surgery, chemotherapy, radiation therapy, and targeted drug therapies. This approach allows patients to receive all of their cancer care, from diagnosis to treatment and follow-up care, in one location. This can be convenient for patients and can help ensure that they receive coordinated and high-quality care.

```
import sqlite3
import pandas as pd


con = sqlite3.connect('cancer.db')
con.execute('''DROP VIEW IF EXISTS All_therapy_at_MSKCC;''')
q1 = (
con.execute('''CREATE VIEW All_therapy_at_MSKCC AS
SELECT  C.All_therapy_at_MSKCC,COUNT(C.All_therapy_at_MSKCC)
FROM CANCER_TYPE C
LEFT JOIN PATIENT P
    ON C.Patient_ID = P.Patient_ID
GROUP BY C.All_therapy_at_MSKCC
ORDER BY C.All_therapy_at_MSKCC;'''))


q1 = (con.execute(''' SELECT * FROM All_therapy_at_MSKCC;'''))


# Convert the SQL query to Pandas data Frame
r1 = pd.read_sql(''' SELECT * FROM All_therapy_at_MSKCC;''', con)
r1.head(1)
print(r1)

# Import libraries
from matplotlib import pyplot as plt
import numpy as np

# Creating dataset
labels = r1['All_therapy_at_MSKCC']
data = r1['COUNT(C.All_therapy_at_MSKCC)']

# Creating plot
fig = plt.figure(figsize =(10, 7))
plt.pie(data, labels = labels)

# show plot
plt.show()
```

<img width="406" alt="MicrosoftTeams-image (32)" src="https://user-images.githubusercontent.com/37552813/205810008-e51f5e60-2729-40bb-8bc8-90bb44e46870.png">

# Query 13 - Platinum Treatment
## Description:
Platinum treatment is a type of chemotherapy that is used to treat cancer. Platinum drugs, such as cisplatin and carboplatin, work by damaging the DNA in cancer cells, which can prevent them from growing and dividing. These drugs are often used in combination with other chemotherapy drugs and can be effective in treating a variety of different types of cancer, including lung cancer, ovarian cancer, and testicular cancer. Common side effects of platinum treatment include nausea, vomiting, hair loss, and an increased risk of infection. It is important for patients to discuss the potential benefits and risks of platinum treatment with their healthcare provider.

```
import sqlite3
import pandas as pd


con = sqlite3.connect('cancer.db')
con.execute('''DROP VIEW IF EXISTS Platinum_Treatment;''')
q1 = (
con.execute('''CREATE VIEW Platinum_Treatment AS
SELECT  A.Platinum_Treatment,COUNT(A.Platinum_Treatment)
FROM ANTIMETABOLITE A
LEFT JOIN PATIENT P
    ON A.Patient_ID = P.Patient_ID
GROUP BY A.Platinum_Treatment
ORDER BY A.Platinum_Treatment;'''))


q1 = (con.execute(''' SELECT * FROM Platinum_Treatment;'''))


# Convert the SQL query to Pandas data Frame
r1 = pd.read_sql(''' SELECT * FROM Platinum_Treatment;''', con)
r1.head(1)
print(r1)

# Import libraries
from matplotlib import pyplot as plt
import numpy as np

# Creating dataset
labels = r1['Platinum_Treatment']
data = r1['COUNT(A.Platinum_Treatment)']

# Creating plot
fig = plt.figure(figsize =(10, 7))
plt.pie(data, labels = labels)

# show plot
plt.show()
```

<img width="400" alt="MicrosoftTeams-image (33)" src="https://user-images.githubusercontent.com/37552813/205810096-ce522f05-cb05-464e-bac6-6dab75c6e979.png">

# Query 14 - Radiotherapy Treatment
## Description:
Radiotherapy, also known as radiation therapy, is a type of cancer treatment that uses high-energy rays, such as X-rays and protons, to kill cancer cells. Radiotherapy works by damaging the DNA in cancer cells, which can prevent them from growing and dividing. It is often used in combination with other cancer treatments, such as chemotherapy and surgery, to kill cancer cells and shrink tumors. Radiotherapy can be an effective treatment for many types of cancer, including breast cancer, prostate cancer, and lung cancer. Common side effects of radiotherapy include fatigue, skin irritation, and an increased risk of infection. It is important for patients to discuss the potential benefits and risks of radiotherapy with their healthcare provider.

```
import sqlite3
import pandas as pd


con = sqlite3.connect('cancer.db')
con.execute('''DROP VIEW IF EXISTS Radiotherapy_Treatment;''')
q1 = (
con.execute('''CREATE VIEW Radiotherapy_Treatment AS
SELECT  R.Radiotherapy_Treatment,COUNT(R.Radiotherapy_Treatment)
FROM RADIOTHERAPY R
LEFT JOIN PATIENT P
    ON R.Patient_ID = P.Patient_ID
GROUP BY R.Radiotherapy_Treatment
ORDER BY R.Radiotherapy_Treatment;'''))


q1 = (con.execute(''' SELECT * FROM Radiotherapy_Treatment;'''))


# Convert the SQL query to Pandas data Frame
r1 = pd.read_sql(''' SELECT * FROM Radiotherapy_Treatment;''', con)
r1.head(1)
print(r1)

# Import libraries
from matplotlib import pyplot as plt
import numpy as np

# Creating dataset
labels = r1['Radiotherapy_Treatment']
data = r1['COUNT(R.Radiotherapy_Treatment)']

# Creating plot
fig = plt.figure(figsize =(10, 7))
plt.pie(data, labels = labels)

# show plot
plt.show()
```

<img width="426" alt="MicrosoftTeams-image (34)" src="https://user-images.githubusercontent.com/37552813/205810180-4827c6cf-1356-4ae3-9253-5ccbd11bd4d8.png">

# Query 15 - Chemotherapy Treatment
## Description:
Chemotherapy is a type of cancer treatment that uses drugs to kill cancer cells. These drugs work by interfering with the way cancer cells grow and divide, which can prevent them from multiplying and spreading to other parts of the body. Chemotherapy is often used in combination with other cancer treatments, such as surgery and radiotherapy, to kill cancer cells and shrink tumors. It can be an effective treatment for many types of cancer, including breast cancer, lung cancer, and leukemia. Common side effects of chemotherapy include nausea, vomiting, hair loss, and an increased risk of infection. It is important for patients to discuss the potential benefits and risks of chemotherapy with their healthcare provider.

```
import sqlite3
import pandas as pd


con = sqlite3.connect('cancer.db')
con.execute('''DROP VIEW IF EXISTS Chemotherapy_Treatment;''')
q1 = (
con.execute('''CREATE VIEW Chemotherapy_Treatment AS
SELECT  C.Chemotherapy_Treatment,COUNT(C.Chemotherapy_Treatment)
FROM CHEMOTHERAPY C
LEFT JOIN PATIENT P
    ON C.Patient_ID = P.Patient_ID
GROUP BY C.Chemotherapy_Treatment
ORDER BY C.Chemotherapy_Treatment;'''))


q1 = (con.execute(''' SELECT * FROM Chemotherapy_Treatment;'''))


# Convert the SQL query to Pandas data Frame
r1 = pd.read_sql(''' SELECT * FROM Chemotherapy_Treatment;''', con)
r1.head(1)
print(r1)

# Import libraries
from matplotlib import pyplot as plt
import numpy as np

# Creating dataset
labels = r1['Chemotherapy_Treatment']
data = r1['COUNT(C.Chemotherapy_Treatment)']

# Creating plot
fig = plt.figure(figsize =(10, 7))
plt.pie(data, labels = labels)

# show plot
plt.show()
```

<img width="425" alt="MicrosoftTeams-image (35)" src="https://user-images.githubusercontent.com/37552813/205810241-e95e252f-326e-4814-9f8c-747b1e44bbcc.png">


# **NORMALISATION**

## Here are 1NF checks that can be used to determine a database 

1. Each table should have a primary key that uniquely identifies each row in the table. This can be a single column, or a combination of multiple columns.

2. Each column in a table should contain a single value, rather than multiple values. For example, if a column is supposed to store a person's name, it should not contain multiple names separated by a delimiter (such as a comma).

3. There should not be any repeating groups in a table. For example, if a table contains information about a person, there should not be multiple rows for that person with different values for some columns. Instead, the data should be organized into separate columns.

4. There should not be any redundant data in a table. For example, if a table contains a column for a person's name and another column for their address, the name should not be repeated in the address column.

Overall, the goal of 1NF is to ensure that data is organized in a structured and consistent manner, making it easier to query and manipulate.


## **2NF** 

Second Normal Form (2NF) is a database design principle that builds on the rules of First Normal Form (1NF). In order to be in 2NF, a database must meet the following criteria:

It must be in 1NF

1. It must not contain any partial dependencies. A partial dependency occurs when a non-prime attribute (an attribute that is not part of the primary key) depends on only a part of the primary key for its values. For example, if a table has a composite primary key (made up of multiple columns), and a non-prime attribute depends on only one of those columns for its values, then the table has a partial dependency and is not in 2NF.

2. It must not contain any transitive dependencies. A transitive dependency occurs when a non-prime attribute depends on another non-prime attribute for its values. For example, if a table has two non-prime attributes (A and B), and the values of attribute A depend on the values of attribute B, then the table has a transitive dependency and is not in 2NF.

3. In general, the goal of 2NF is to ensure that the values in a table are fully dependent on the primary key, and not on any other non-prime attributes. This helps to ensure that data is stored in a logical and consistent manner, making it easier to query and manipulate. By following these guidelines, you can improve the performance and reliability of your database.


## **3NF**

Third Normal Form (3NF) is a database design principle that builds on the rules of First Normal Form (1NF) and Second Normal Form (2NF). In order to be in 3NF, a database must meet the following criteria:

It must be in 2NF

1. It must not contain any transitive dependencies. A transitive dependency occurs when a non-prime attribute depends on another non-prime attribute for its values. For example, if a table has two non-prime attributes (A and B), and the values of attribute A depend on the values of attribute B, then the table has a transitive dependency and is not in 3NF.

2. It must not contain any non-prime attributes that are functionally dependent on another non-prime attribute. A non-prime attribute is functionally dependent on another non-prime attribute when the values of the first attribute are determined by the values of the second attribute. For example, if a table has two non-prime attributes (A and B), and the values of attribute A are determined by the values of attribute B, then the table is not in 3NF.

3. In general, the goal of 3NF is to ensure that the values in a table are fully dependent on the primary key, and not on any other non-prime attributes. This helps to ensure that data is stored in a logical and consistent manner, making it easier to query and manipulate. By following these guidelines, you can improve the performance and reliability of your database.


## **Views** 

1. A view in a database is a virtual table that is created by querying one or more existing tables. It provides a way to view and manipulate data from those tables in a specific way, without having to actually store the data in a separate table.

2. Views are often used to simplify the structure of a database, or to provide a different perspective on the data. For example, a view could be used to show only a subset of the data in a table, or to combine data from multiple tables into a single view.

3. Views are typically created using a SQL query, and can be accessed and queried just like a regular table. However, unlike regular tables, views do not store any data themselves – they are simply a way of presenting data from one or more tables in a specific way. This means that views can be created and modified quickly and easily, without having to make any changes to the underlying tables.




